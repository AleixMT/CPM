#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <assert.h>
#include <omp.h>
#define CERT 1
#define FALS 0
// Ha de ser inicialment correcta !!
int taula[9][9] = \
        {1,2,3, 4,5,6,  7,8,9,  \
         9,8,7, 3,2,1,  6,5,4,  \
         6,5,4, 7,8,9,  1,2,3,  \
\
         7,9,8, 1,0,0,  0,0,0,  \
         0,0,0, 0,0,0,  0,0,0,  \
         0,0,0, 0,0,0,  0,0,0,  \
\
         0,0,0, 0,0,0,  0,0,0,  \
         0,0,0, 0,0,0,  0,0,0,  \
         0,0,0, 0,0,0,  0,0,0};


int puc_posar(int x, int y, int z)
{
	int i,j,pi,pj;
	int boolean1=CERT, boolean2=CERT, boolean3=CERT;
	//#pragma omp threadprivate(i,j,pi,pj)
	//#pragma omp parallel default(none) copyin(i,j,pi,pj) firstprivate(x,y,z) shared(stdout, taula, boolean1, boolean2, boolean3)
	//{
	//#pragma omp sections
	//{
	//#pragma omp section
	//{
	//printf("x => %d, %d ", x, y); fflush(stdout);
	for (i=0;i<9;i++)
	{
		//if(x==6){printf("%d, %d := %d = %d \n", x, y, taula[x][i], z); fflush(stdout);} 
		if (taula[x][i] == z) {
			boolean1=FALS; // Files	
			//printf("%d = %d\n", taula[x][i] , z); fflush(stdout);
		}	
	}
	//}
	//#pragma omp section
	//{
	//printf("y => %d ",y); fflush(stdout);
	for (i=0;i<9;i++) if (taula[i][y] == z) boolean2=FALS; // Columnes
 	//}
	// Quadrat
	//#pragma omp section
	//{
	pi = (x/3)*3; //truncament
	pj = y-y%3; //truncament
 	for (i=0;i<3;i++) 
  		for (j=0;j<3;j++) 
			if (taula[pi+i][pj+j] == z) boolean3=FALS;
	//}
	//}
	//#pragma omp barrier
	//}	
	if((boolean1==FALS)|(boolean2==FALS)|(boolean3==FALS))
	{
	// 		printf("falso, %d, %d, %d - %d %d %d \n", x,y, z, boolean1, boolean2, boolean3);fflush(stdout);

	//	printf("%d, %d, %d\n", boolean1, boolean2, boolean3);
	//	fflush(stdout);

		return(FALS);
	}
	else{
		if(x==4 & y==0){printf("cierto, %d, %d, %d - %d %d %d \n", x,y, z, boolean1, boolean2, boolean3);fflush(stdout);}
		return(CERT);
	}
}

////////////////////////////////////////////////////////////////////
int recorrer( int i, int j)
{
	int k;
	long int s=0;
		
 	if (taula[i][j]) //Valor fixe no s'ha d'iterar
  	{
     		if (j<8) return(recorrer(i,j+1));
     		else if (i<8) return(recorrer(i+1,0));
     		else return(1); // Final de la taula
  	}
 	else // hi ha un 0 hem de provar
  	{
	   	for (k=1;k<10;k++)
   		{
    			if (puc_posar(i,j,k)==CERT)
     			{
       				//printf("%d %d %d\n",i,j,k);
				//fflush(stdout);
				taula[i][j]= k; 
	 			if (j<8) s += recorrer(i,j+1);
	 			else if (i<8) s += recorrer(i+1,0);
				else {
					s++;
				//printf("%ld\n", s);
				//fflush(stdout);
				}
      				taula[i][j]= 0;
    				

			}
						
   		}
  	}
	return(s);
}

////////////////////////////////////////////////////////////////////
int main()
{	
	//#pragma omp threadprivate(taula)
	int i, j;	
	long int nsol;
	omp_set_num_threads(4);
	i=0;
	j=0; 
	nsol = recorrer(i,j);
	printf("numero solucions : %ld\n",nsol);
	exit(0);
}
